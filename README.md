# Лекции
---
+ Здесь будут находиться папки для каждой рассмотренной на лекции программы.
+ Студент группы КТСО-05-20 Румянцев Василий
---
Операционные системы, на которых построен проект:
+ GNU/Linux - да;
+ Windows - да;
+ Mac OS - не уверен.
## Установка
Каждую программу можно запустить с помощью `gcc <название_программы.c>`. В директории создастся  файл `a.out`, который можно запустить с помощью `./a.out`. </br>
Или же использовать `gcc <название_программы.c> -o <название_скомпилированной_программы.out>`, тогда в директории создастся исполняемый файл, запускать его можно через `./название_скомпилированной_программы.out`.  </br> </br>
Но легче всего запустить Makefile, он лежит в папке с этим ридми. Запускается так - `make all`. </br>
После этого в папке каждой программы будет создан исполняемый файл с ней (расширение `.out`). </br>

___

## Что делают программы и вывод результата их работы
#### Программа №1
Сначала  указывается длина массив. Потом происходит проверка на ввод, приложение выделяет память для массива. Если память не выделилась, функция malloc вернёт NULL. После этого приложение выведет количество байтов, которое было выделено,а после очистит выделенную память.

Тест 1
```
Enter length of array: 10  
Allocated 40 bytes  
```
Тест 2
```
Enter length of array: -25  
Error: can't allocate memory: Not enough space  
```
___ 
#### Программа №2
В начале выделяем память для массива с помощью функции calloc. Затем приложение создает и открывает файл foo.txt. После этого выводится значение дескриптора файла. После этого приложение прочтёт из файла 10 байт и запишет полученное количество информации в переменную sz. Затем программа запишет в конец массива терминальный ноль и закроет файл.

Тест  
```
fd = 3  
called read( 3, c, 10). returned that 0 bytes were read.  
closed the fd.  
```
___
#### Программа №3
В начале мы вызываем функцию fork, которая создаёт дочерний процесс.Далее программа  выведет PID'ы процесса в котором находится.

Тест  
```
my pid = 3441, returned pid = 3442  
my pid = 3442, returned pid = 0  
```
___
#### Программа №4
Создаются две обрабатывающие функции, которые принимают на вход наш сигнал с типом данных Int. Обработка выглядит следующим образом: Программа привязывает первую функцию обработки к текущему процессу. Далее если процесс окажется дочерним, сигнал будет обрабатывать уже другая функция.

Тест  
```
counter = 1  
counter = 3  
counter = 5  
```
___

#### Программа №5
У нас есть два дескриптора, которые при помощи функции pipe мы записываем с обработкой ошибки. Затем вызываем функцию fork для получения идентификатора дочернего процесса. Если этот идентификатор равен 0, то это значит, что мы потомок. В один дескриптор мы будет писать, а в другом принимать информацию. То есть мы передаем сообщение между процессами по средствам каналов.

Тест
```
$ ./a.out Nice time!  
Nice time!  
```
___

#### Программа №6
В начале мы создаём дескриптор канала и канал с правами доступа для всех. Затем выполняется проверка. После запускается бесконечный цикл, для прослушивания этого канала. Когда в этот канал попадет какое-то сообщение, то будет выведено количество символов (+1 на терминальный ноль) в этом сообщении и само сообщение.

Тест  
```
my_named_pipe is created  
$ echo 123 > my_named_pipe  
my_named_pipe is opened  
Incomming message (13): 123  
  
read error: Success  
```
Команду "$ echo 123 > my_named_pipe" нужно вписать во втором терминале, иначе программа не выведет значение.

